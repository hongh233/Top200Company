## Details of how I generated any simulated part of my data

- City (headquarters_city, population, median_individual_income, happiness_index). 

There are 114 rows in this table. The headquarters_city is from the Kaggle dataset: 2023 Fortune 1000 Companies. There are two attributes in the original dataset: headquartersCity and headquartersState, I concatenate them to headquartersCity because I find different states can have same city name, so the concatenation will be unique. The happiness_index attribute is generated by ChatGPT (reference list 8) by asking them: ”Generating me some happiness_index DECIMAL(5,2) for me, and the amount should be 120.” The population and median_individual_income information are from data commons (reference list 7), the reference list provide an example how to search for population when we having a specific city.

- Sector (sector_name, innovation_level, innovation_direction, sector_development_index). 

There are 21 rows in this table. Sector_name is from Kaggle dataset, and other attributes are generated by ChatGPT (reference list 2) by giving list of sector_name and asking them: “Please generate innovation_direction, innovation_level and sector_development_index for these sectors”.

- Industry (industry_name, sector_name, average_revenue, average_profit_rate). 

There are 60 rows in this table. Industry_name and sector_name are from Kaggle: 2023 Fortune 1000 Companies, also the same idea that take top 200 rows. For the average_revenue and average_profit_rate I generate them by ChatGPT (reference list 4) and (reference list 5) by giving industry_name and asking: “provide me with some average_revenue and average_profit_rate”.

- Company (company_name, company_rank, industry_name, global_presence, founder_is_CEO, headquarters_city, company_type, number_of_employees). 

There are 200 rows in this table. This table is reference from Kaggle dataset: 2023 Fortune 1000 Companies. I only take top 200 rows from the dataset, choose some of the attributes and rename it. Only for the global_presence, I generate it by ChatGPT (reference list 3) by asking: “Please provide me with some global_presence.”

- CEO (CEO_name, company_name, year_of_birth, highest_degree, university_name, major_name, CEO_is_female). 

There are 204 rows in this table. The CEO_name and company_name is from Kaggle dataset: 2023 Fortune 1000 Companies. The rest attributes are search on the wikipedia (reference list 8), LinkedIn (reference list 9), MarketScreener (reference list 10) and Business Roundtable (reference list 11). These references are examples to search the informations for the rest attributes. First we copy the CEO_name and search on the wikipedia, if it not exist, then we try LinkedIn, if it not exist, then we try MarketScreener, if it not exist, then we try Business Roundtable. These steps are powerful enough to get all the informations of CEOs’.

- Financial Performance (company_name, revenues, revenue_percent_change, profits, profits_percent_change). 

There are 200 rows in this table. This table is completely get from Kaggle: 2023 Fortune 1000 Companies. I get some of the financial performance from it.

## Details of the tables

This database contains six tables: City (4 columns, 114 rows), Sector (4 columns, 21 rows), Industry (4 columns, 60 rows), Company (8 columns, 200 rows), CEO (7 columns, 204 rows), Financial Performance (5 columns, 200 rows).

Company has a foreign key headquarters_city reference to City(headquarters_city), which means one city can have multiple companies to set their headquarters in the city, and one company can have only one headquarters city. Company also has a foreign key industry_name reference to Industry(industry_name), which means one company has one industry and one Industry has multiple companies. Industry table has a foreign key sector_name reference to Sector(sector_name), which means one industry has one sector and one sector can have multiple industries. The CEO table has a foreign key company_name reference to Company(company_name), expressing that one CEO controls one company and one company can have multiple CEOS(co-CEO). The Financial Performance table has a foreign key company_name reference to Company(company_name), which means one company can have one financial performance and one financial performance refers to one company. The company_name is also the primary key in Financial Performance so the relationship is strong, and we will use solid line. Other foreign keys are not primary key or part of composite primary key, so their relationships are weak and we will use dash line. In City, the primary key is headquarters_city, it will uniquely identify all the headquarters_city. Since it is very long, we use VARCHAR(50). In Company, we use company_name as the primary key, which expresses each company. The company_name is long so we use VARCHAR(50). In Industry, we use industry_name as the primary key. In Sector, we use sector_name as the primary key. In CEO, we use CEO_name as the primary key. In Financial Performance, we use company_name as the primary key. These keys all use names, which can clearly express the table and uniquely identify all the rows in the table. Because all the primary keys (also foreign keys) I choose are names, I use VARCHAR(50) or VARCHAR(100) as datatype, it is based on the length of the data. Other data types are based on our needs. In the City table, the population of the city and median_individual_income is an integer number and it is in the range of INT so we use INT, the population must greater than 0; happiness_index is decimal number which accurate to two decimal place and range from 0 to 10 so I use DECIMAL(5,2). In the Sector table, innovation_level is a short string and it can be either ‘Low’, ’Moderate-Low’, ’Moderate’, ’Moderate-High’, ’High’, therefore I use VARCHAR(15); the innovation_direction is a little bit long so I use VARCHAR(50); the sector_development_index is a decimal number which accurate to one decimal place and range from 0 to 10, so I use DECIMAL(4,1). In the Industry table, the average_revenue is a big integer so I use BIGINT; the average_profit_rate is a percentage number which accurate to one decimal place so I use DECIMAL(4,1). In the Company table, the company_rank is a small integer, so I use INT; the global_presence is a short string which can be either ‘Low’, ’Moderate-Low’, ’Moderate’, ’Moderate-High’ and ’High’, so I use VARCHAR(15); the founder_is_CEO is a logic which can be either true or false, so I use BOOLEAN; the company_type is either ‘public’ or ‘private’, so I use VARCHAR(10); the number_of_employees is an integer in the range of INT, so I use INT, and the number_of_employees should greater than 0. In the CEO table, year_of_birth is a 4 digit number, so I use CHAR(4); highest_degree is a medium-length string which can be either 'Bachelor','Master', 'Doctor', 'Bachelor(dropped out)', so I use VARCHAR(30); university_name is a long string, so I use VARCHAR(100); major_name is also a long string, so I use VARCHAR(50); CEO_is_female is either true or false so I use BOOLEAN as datatype. In the Financial Performance table, revenues and profits are a very big integer, so we use BIGINT; revenue_percent_change and profits_percent_change are decimal numbers which accurate to one decimal place, so I use DECIMAL(10,1). Additionally, for all the attributes referring to money, we use US dollars as units. 

## Explanation of why these tables are 3NF

(See the internal schema and dependency diagram in ./diagram)

In my internal schema I have six tables, so I have six dependency diagrams totally. In my diagram, the green means primary key and the blue means nonprime attributes. All dependencies are indicated with red arrows. In diagram Sector, since sector_name is the primary key, the value of sector_name directly determines the value of all the other attributes. Other attributes are not key to the Sector table, so there will not have any other dependencies. In diagram Industry, since industry_name is the primary key, the value of industry_name directly determines the value of all the other attributes. Other attributes are not key to the Industry table, so there will not have any other dependencies. In diagram City, the same as the Industry table, headquarters_city is the primary key and it will determine all the other attributes. Other attributes for example population is meaningless to be a key, and also there will not have any other dependencies. In diagram Company, the company_name is the primary key so it will determine all the other attributes. Different from other diagrams, the Company table has a candidate key: company_rank, which can also uniquely identify all the rows in the table, because one company will have a unique rank. Therefore company_rank will also determine all the other attributes. And this allows the 3NF rule because in the Company table the company_rank determines all the other attributes, this is not a transitive dependency or partial dependencies. For any other attributes, there doesn't exist any other dependencies. In diagram CEO, the CEO_name is the primary key and it will determine all the other attributes. It is not good to think that year_of_birth,highest_degree, university_name can determine a CEO, because there might be multiple CEOs who have the same birth year and study in the same university and in the same major. Therefore there will not be any other dependencies. In diagram Financial Performance, the company_name is the primary key and it will determine all the other attributes. It is meaningless to consider profit or other data in integer or decimal to determine company_name. Therefore there will not be any other dependencies. To summarize, this database is in 3NF, because in each table the primary key identifies each row uniquely, and there are no multivalued attributes, and there are no repeated columns, and also it contains no partial dependencies and transitive dependencies.
It is worth mentioning that although the Company table has a candidate key company_rank, we didn’t write red arrow to express that, because we don’t care about the relation. What we just care about is whether the dependency diagram has a transitive dependency or partial dependency, if it has, it will not be 3NF.
